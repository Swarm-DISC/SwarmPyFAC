
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>swarmpyfac.fac &#8212; SwarmPyFAC 0.1.1 documentation</title>
    <link rel="stylesheet" href="../../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">SwarmPyFAC 0.1.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for swarmpyfac.fac</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot; The fac module is used for calculated field alligned currents.</span>

<span class="sd">This module contains functions used to calculated field alligned currents,</span>
<span class="sd">and some of the components used in the calculations.</span>
<span class="sd">This module is dependent on the swarm_util module, which contains</span>
<span class="sd">functions for utilities and some of the more general components needed.</span>

<span class="sd">This module currently only allows caluculation of the single satelite</span>
<span class="sd">version of the FAC product, and it uses data available from viresclient&#39;s</span>
<span class="sd">python client or another data source with similar format.</span>
<span class="sd">The major difference between this and the official ESA product,</span>
<span class="sd">is that the input from models are their effects at each measurement point,</span>
<span class="sd">since this is the format delivered by viresclient.</span>

<span class="sd">This means that there is a small algorithmic difference compared</span>
<span class="sd">to what is used in the official ESA products,</span>
<span class="sd">though experimental comparison have found the difference </span>
<span class="sd">to be less than  1.2*10^(-4) micro A/m^2, and the average</span>
<span class="sd">difference to be less than 1% of this.</span>

<span class="sd">Running this module as a script will (outside of running some tests)</span>
<span class="sd">perform the default experiment.</span>

<span class="sd">Overview</span>
<span class="sd">--------</span>
<span class="sd">This section lists each of the functions in this module,</span>
<span class="sd">and give a short description of them.</span>
<span class="sd">You can use this as an easier way to look up what you might need.</span>

<span class="sd">split_models</span>
<span class="sd">    Takes measurements and up to several models,</span>
<span class="sd">    and returns the combined model and the residual on the measurements.</span>
<span class="sd">radial_current</span>
<span class="sd">    Calculate the radial currents for time-like series.</span>
<span class="sd">single_sat_fac</span>
<span class="sd">    Calculate the field alligned currents</span>
<span class="sd">    for a single satelinte on time-like series.</span>
<span class="sd">single_sat_fac_full</span>
<span class="sd">    Like single_sat_fac, but it handles input from a dictionary,</span>
<span class="sd">    and can figure out which models are pressent itself.</span>
<span class="sd">fetch_data</span>
<span class="sd">    Fetch the data needed, and can figure out itself whether</span>
<span class="sd">    it needs to download it first.</span>
<span class="sd">fac_from_file</span>
<span class="sd">    Do the entire single satelite field alligned currents calculations,</span>
<span class="sd">    but takes a possible file as input the same way as fetch_data.</span>

<span class="sd">Examples</span>
<span class="sd">--------</span>
<span class="sd">&gt;&gt;&gt; from pyfac.fac import fac_from_file  # doctest: +SKIP</span>
<span class="sd">&gt;&gt;&gt; import datetime as date</span>
<span class="sd">&gt;&gt;&gt; results, input_data = fac_from_file(</span>
<span class="sd">...     start=date.datetime(2017, 4, 11),</span>
<span class="sd">...     end=date.datetime(2017, 4, 12),</span>
<span class="sd">...     force_download=True)  # doctest: +SKIP</span>
<span class="sd">&gt;&gt;&gt; lat, fac = results[1][:, 0], results[3]  # doctest: +SKIP</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="c1"># &quot;&quot;&quot; A slim version of the FAC level 2 processing,</span>
<span class="c1"># but when using viresclient data instead of official ESA products.</span>
<span class="c1"># &quot;&quot;&quot;</span>

<span class="n">__version__</span> <span class="o">=</span> <span class="s1">&#39;0.5.0&#39;</span>
<span class="n">__author__</span> <span class="o">=</span> <span class="s1">&#39;Ask Neve Gamby&#39;</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">scipy.interpolate</span> <span class="k">as</span> <span class="nn">sii</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">safety</span> <span class="k">as</span> <span class="n">safe_user</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">utils</span> <span class="k">as</span> <span class="n">sw</span>

<span class="n">_INKL_LIMIT</span> <span class="o">=</span> <span class="mf">30.</span>

<span class="n">base_pairs</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;time&#39;</span><span class="p">:</span> <span class="s1">&#39;Timestamp&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Theta&#39;</span><span class="p">:</span> <span class="s1">&#39;Latitude&#39;</span><span class="p">,</span> 
    <span class="s1">&#39;phi&#39;</span><span class="p">:</span> <span class="s1">&#39;Longitude&#39;</span><span class="p">,</span> 
    <span class="s1">&#39;r&#39;</span><span class="p">:</span> <span class="s1">&#39;Radius&#39;</span>
    <span class="p">}</span>

<span class="n">_name_pairings</span> <span class="o">=</span> <span class="p">{</span>
    <span class="o">**</span><span class="n">base_pairs</span><span class="p">,</span>
    <span class="s1">&#39;B_base&#39;</span><span class="p">:</span> <span class="s1">&#39;B_NEC&#39;</span><span class="p">,</span>
    <span class="s1">&#39;B_core&#39;</span><span class="p">:</span> <span class="s1">&#39;B_NEC_MCO_SHA_2C&#39;</span><span class="p">,</span>
    <span class="s1">&#39;B_lithosphere&#39;</span><span class="p">:</span> <span class="s1">&#39;B_NEC_MLI_SHA_2C&#39;</span><span class="p">,</span>
    <span class="s1">&#39;B_magnetosphere_primary&#39;</span><span class="p">:</span> <span class="s1">&#39;B_NEC_MMA_SHA_2C-Primary&#39;</span><span class="p">,</span>
    <span class="s1">&#39;B_magnetosphere_secondary&#39;</span><span class="p">:</span> <span class="s1">&#39;B_NEC_MMA_SHA_2C-Secondary&#39;</span><span class="p">,</span>
    <span class="p">}</span>


<div class="viewcode-block" id="split_models"><a class="viewcode-back" href="../../reference.html#swarmpyfac.fac.split_models">[docs]</a><span class="k">def</span> <span class="nf">split_models</span><span class="p">(</span><span class="n">baseline</span><span class="p">,</span> <span class="o">*</span><span class="n">models</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Seperate the effect of models from the baseline.</span>
<span class="sd">    </span>
<span class="sd">    Seperate the effect of model and risidual on the baseline,</span>
<span class="sd">    base on precalculated effects of each model.</span>
<span class="sd">    It is assumed that the models combine linearly with each</span>
<span class="sd">    other and a residual (meaning modelA + modelB + residual = baseline,</span>
<span class="sd">    but not modelA * modelB + residual = baseline or other such variations).</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    baseline : ndarray</span>
<span class="sd">        An array of the base measurements.</span>
<span class="sd">    *models : ndarray</span>
<span class="sd">        Arrays of the effects of each model to be removed.</span>
<span class="sd">        all models must have the same length as baseline.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple of ndarray</span>
<span class="sd">        A tuple, with the first component being an ndarray of the residual</span>
<span class="sd">        and the second component being an ndarray of the combined model.</span>
<span class="sd">        The result statisfies that the sum of the components</span>
<span class="sd">        is equal to the baseline.</span>
<span class="sd">        </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from pyfac.fac import *  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; modelA = np.arange(15).reshape(5,3)**2</span>
<span class="sd">    &gt;&gt;&gt; modelB = sw.as_3d(np.arange(7,2,-1))</span>
<span class="sd">    &gt;&gt;&gt; data = (np.random.randn(5,3)*0.1 + modelA + modelB </span>
<span class="sd">    ...         + sw.pack_3d(np.sin(np.arange(5)*0.5),</span>
<span class="sd">    ...                      np.cos(np.arange(5)*0.5),</span>
<span class="sd">    ...                      np.tan(np.arange(5)*0.5)))</span>
<span class="sd">    &gt;&gt;&gt; split_models(data,modelA,modelB) # doctest: +ELLIPSIS</span>
<span class="sd">    (array([[...,...,...],</span>
<span class="sd">           [...,...,...],</span>
<span class="sd">           [...,...,...],</span>
<span class="sd">           [...,...,...],</span>
<span class="sd">           [...,...,...]]), array([[  7.,   8.,  11.],</span>
<span class="sd">           [ 15.,  22.,  31.],</span>
<span class="sd">           [ 41.,  54.,  69.],</span>
<span class="sd">           [ 85., 104., 125.],</span>
<span class="sd">           [147., 172., 199.]]))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">model</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">models</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">baseline</span> <span class="o">-</span> <span class="n">model</span><span class="p">,</span>
            <span class="n">model</span><span class="p">)</span></div>


<div class="viewcode-block" id="radial_current"><a class="viewcode-back" href="../../reference.html#swarmpyfac.fac.radial_current">[docs]</a><span class="k">def</span> <span class="nf">radial_current</span><span class="p">(</span><span class="n">delta_B</span><span class="p">,</span> <span class="n">velocity</span><span class="p">,</span> <span class="n">delta_time</span><span class="p">,</span> <span class="n">MU_0</span><span class="o">=</span><span class="n">sw</span><span class="o">.</span><span class="n">MU_0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Calculate the radial curents (IRC) over a time series.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    delta_B : ndarray</span>
<span class="sd">        The change in the B (magnetic) field in a time series in</span>
<span class="sd">        an ndarray of vectors.</span>
<span class="sd">        Standard use requires this to be in the VSC frame.</span>
<span class="sd">    velocity : ndarray</span>
<span class="sd">        An ndarray of vectors of the spartial velocities</span>
<span class="sd">        at each point in the timeseries.</span>
<span class="sd">    delta_time : ndarray</span>
<span class="sd">        An ndarray of scalars of the time steps between </span>
<span class="sd">        each point in the timeseries of delta_B and velocity.</span>
<span class="sd">    MU_0 : float, optional</span>
<span class="sd">        The constant of permubility of vacum, in the given units.</span>
<span class="sd">        Defaults to swarm_util.MU_0, which assumes velocity </span>
<span class="sd">        and delta_time are in base SI units, and delta_B in nT.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        An ndarray of vectors, each of which describes</span>
<span class="sd">        the radial current at the respective point in the timseries.</span>
<span class="sd">        </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from pyfac.fac import *  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; vecs = sw.delta(np.arange(15).reshape(5,3))</span>
<span class="sd">    &gt;&gt;&gt; radial_current(vecs,vecs,np.ones(len(vecs)))</span>
<span class="sd">    array([-0., -0., -0., -0.])</span>
<span class="sd">    &gt;&gt;&gt; radial_current(vecs, sw.pack_3d(np.ones((4,)),-1.5 * np.ones((4,)),np.zeros((4,))),np.ones(len(vecs)))</span>
<span class="sd">    array([-1989.43678865, -1989.43678865, -1989.43678865, -1989.43678865])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">change</span> <span class="o">=</span> <span class="n">sw</span><span class="o">.</span><span class="n">curl</span><span class="p">(</span><span class="n">delta_x</span><span class="o">=</span><span class="n">velocity</span><span class="p">,</span> <span class="n">delta_field</span><span class="o">=</span><span class="n">delta_B</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">((</span><span class="o">-.</span><span class="mi">001</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">MU_0</span><span class="p">))</span> <span class="o">*</span> <span class="n">change</span> <span class="o">/</span> <span class="n">delta_time</span><span class="p">)</span></div>


<div class="viewcode-block" id="single_sat_fac"><a class="viewcode-back" href="../../reference.html#swarmpyfac.fac.single_sat_fac">[docs]</a><span class="k">def</span> <span class="nf">single_sat_fac</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">positions</span><span class="p">,</span> <span class="n">B_res</span><span class="p">,</span> <span class="n">B_model</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Calculate the Field Aligned Currents on a single satelites path.</span>
<span class="sd">    </span>
<span class="sd">    This function runs through the same logic as needed for the single</span>
<span class="sd">    satelite version of the official FAC product.</span>
<span class="sd">    This function is not designed to deal with data flaged in some way as bad.</span>
<span class="sd">    There are several extra outputs usefull for debuging and comparisons.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    time : ndarray</span>
<span class="sd">        An array of scalars of time stamps in seconds.</span>
<span class="sd">    poisitions : ndarray</span>
<span class="sd">        An array of vectors (theta, phi,r) of the position of the </span>
<span class="sd">        satelite in spherical coordinates.</span>
<span class="sd">    B_res : ndarray</span>
<span class="sd">        An array of vectors of the residual of the magnetic field </span>
<span class="sd">        measurements after the model have been substracted.</span>
<span class="sd">        The vectors are assumed to be in the NEC coordinate system.</span>
<span class="sd">    B_model : ndarray</span>
<span class="sd">        An array of vectors of the model of the magnetic field</span>
<span class="sd">        at the point of measurements.</span>
<span class="sd">        The vectors are assumed to be in the NEC coordinate system.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    The return is a tuple consiting of the following:</span>
<span class="sd">    time : ndarray</span>
<span class="sd">        An ndarray of  scalars describing the time each point</span>
<span class="sd">        in the calculations corrisond to.</span>
<span class="sd">        Note that it is off compared to the parameter time.</span>
<span class="sd">    position : ndarray</span>
<span class="sd">        An ndarray of spherical coordinates describing the postion</span>
<span class="sd">        of each point in the time series where the calculations</span>
<span class="sd">        are suppose to apply at. The coordinates are arranged as</span>
<span class="sd">        theta, phi, r.</span>
<span class="sd">        Note tht this is off compared to the parameter positions.</span>
<span class="sd">    irc : ndarray</span>
<span class="sd">        An ndarray of vectors of the radial currents (the radial components,</span>
<span class="sd">        of currents) found when solving one of Maxwells equations</span>
<span class="sd">        on the magnetic field.</span>
<span class="sd">        Note that this is given in the VSC (spacecraft velocity) frame.</span>
<span class="sd">    fac : ndarray</span>
<span class="sd">        An ndarray of vectors of the field alligned currents.</span>
<span class="sd">        Note that this is given in the VSC (spacecraft velocity) frame.</span>
<span class="sd">    V : ndarray</span>
<span class="sd">        An ndarray of vectors of the velocity in the NEC frame.</span>
<span class="sd">    V_VSC : ndarray</span>
<span class="sd">        An ndarray of vectors of the velocity in the VSC frame.</span>
<span class="sd">    pos_ltl : ndarray</span>
<span class="sd">        An ndarray of scalars of positions where local time is acounted for.</span>
<span class="sd">        Each position reference the same position as positions output.</span>
<span class="sd">        Note tht this is off compared to the parameter positions.</span>
<span class="sd">    inclination :</span>
<span class="sd">        An ndarray of scalars of the inclination of the aproximation </span>
<span class="sd">        of the magnetic field, where the calculations</span>
<span class="sd">        are supposed to be applied at.</span>
<span class="sd">        </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from pyfac.fac import *  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; time = np.arange(0,10,0.1)</span>
<span class="sd">    &gt;&gt;&gt; positions = sw.pack_3d(np.sin(0.01 * time)*90,(0.01 * time % np.pi)/sw.TO_RADIANS ,np.ones(len(time)))</span>
<span class="sd">    &gt;&gt;&gt; B_res = np.random.randn(len(time),3)* sw.as_3d(10 *positions[:,1])</span>
<span class="sd">    &gt;&gt;&gt; B_model = sw.as_3d(positions[:,2])*sw.pack_3d(np.sin(positions[:,0]),np.zeros(len(time)),2*np.cos(positions[:,0]))</span>
<span class="sd">    &gt;&gt;&gt; single_sat_fac(time,positions,B_res,B_model)  # doctest: +ELLIPSIS</span>
<span class="sd">    (array([...]), array([[...]]), array([...]), array([...]), array([[...]]), array([[...]]), array([[...]]), array([...]))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">sw</span><span class="o">.</span><span class="n">delta</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
    <span class="n">pos_ltl</span> <span class="o">=</span> <span class="n">sw</span><span class="o">.</span><span class="n">pack_3d</span><span class="p">(</span><span class="n">positions</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span>
                         <span class="p">((</span><span class="n">positions</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">180</span> <span class="o">+</span> <span class="n">time</span><span class="o">/</span><span class="mi">86400</span> <span class="o">*</span> <span class="mi">360</span><span class="p">)</span><span class="o">%</span><span class="mi">360</span><span class="p">)</span><span class="o">-</span><span class="mi">180</span><span class="p">,</span>
                         <span class="n">positions</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">sw</span><span class="o">.</span><span class="n">spherical_delta</span><span class="p">(</span><span class="n">pos_ltl</span><span class="p">)</span><span class="o">/</span><span class="n">sw</span><span class="o">.</span><span class="n">as_3d</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
    <span class="n">transform</span> <span class="o">=</span> <span class="n">sw</span><span class="o">.</span><span class="n">NEC_to_VSC</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">V_VSC</span> <span class="o">=</span> <span class="n">transform</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>  <span class="c1"># V is in VSC frame now</span>
    <span class="n">B1</span> <span class="o">=</span> <span class="n">transform</span><span class="p">(</span><span class="n">B_res</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">B2</span> <span class="o">=</span> <span class="n">transform</span><span class="p">(</span><span class="n">B_res</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="c1">#transform(sw.delta(B_res)</span>
    <span class="n">irc</span> <span class="o">=</span> <span class="n">radial_current</span><span class="p">(</span><span class="n">B2</span><span class="o">-</span><span class="n">B1</span><span class="p">,</span> <span class="n">V_VSC</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
    <span class="n">target_time</span> <span class="o">=</span> <span class="n">sw</span><span class="o">.</span><span class="n">means</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
    <span class="n">B_interpolated</span> <span class="o">=</span> <span class="n">sw</span><span class="o">.</span><span class="n">map_3d</span><span class="p">(</span><span class="k">lambda</span> <span class="n">data</span><span class="p">:</span> 
        <span class="n">sii</span><span class="o">.</span><span class="n">splev</span><span class="p">(</span><span class="n">target_time</span><span class="p">,</span><span class="n">sii</span><span class="o">.</span><span class="n">splrep</span><span class="p">(</span><span class="n">time</span><span class="p">,</span><span class="n">data</span><span class="p">)),</span>
        <span class="n">B_model</span><span class="p">)</span>
    <span class="n">inclination</span> <span class="o">=</span> <span class="n">sw</span><span class="o">.</span><span class="n">inclination</span><span class="p">(</span><span class="n">B_interpolated</span><span class="p">)</span> <span class="c1">#we approximate local field by interpolation</span>
    <span class="n">fac</span> <span class="o">=</span> <span class="o">-</span><span class="n">irc</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">inclination</span><span class="p">)</span>
    <span class="n">fac</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">inclination</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">_INKL_LIMIT</span> <span class="o">*</span> <span class="n">sw</span><span class="o">.</span><span class="n">TO_RADIANS</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">is_good</span> <span class="o">=</span> <span class="n">dt</span> <span class="o">&lt;=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">sw</span><span class="o">.</span><span class="n">means</span><span class="p">(</span><span class="n">time</span><span class="p">)[</span><span class="n">is_good</span><span class="p">],</span>
            <span class="n">sw</span><span class="o">.</span><span class="n">means</span><span class="p">(</span><span class="n">positions</span><span class="p">)[</span><span class="n">is_good</span><span class="p">],</span>
            <span class="n">irc</span><span class="p">[</span><span class="n">is_good</span><span class="p">],</span>
            <span class="n">fac</span><span class="p">[</span><span class="n">is_good</span><span class="p">],</span>
            <span class="n">V</span><span class="p">[</span><span class="n">is_good</span><span class="p">],</span>
            <span class="n">V_VSC</span><span class="p">[</span><span class="n">is_good</span><span class="p">],</span>
            <span class="n">sw</span><span class="o">.</span><span class="n">means</span><span class="p">(</span><span class="n">pos_ltl</span><span class="p">)[</span><span class="n">is_good</span><span class="p">],</span>
            <span class="n">inclination</span><span class="p">[</span><span class="n">is_good</span><span class="p">])</span></div>


<div class="viewcode-block" id="single_sat_fac_full"><a class="viewcode-back" href="../../reference.html#swarmpyfac.fac.single_sat_fac_full">[docs]</a><span class="k">def</span> <span class="nf">single_sat_fac_full</span><span class="p">(</span><span class="n">input_data</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Calculate the Field Aligned Currents on a single satelites path.</span>
<span class="sd">    </span>
<span class="sd">    This is mainly designed as a wrapper for single_sat_fac,</span>
<span class="sd">    which can extract the relevant parameters from a dictionary</span>
<span class="sd">    </span>
<span class="sd">    This function runs through the same logic as needed for the single</span>
<span class="sd">    satelite version of the official FAC product.</span>
<span class="sd">    This function is not designed to deal with data flaged in some way as bad.</span>
<span class="sd">    There are several extra outputs usefull for debuging and comparisons.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    There is only one parameter: input_data, which is a dictionary.</span>
<span class="sd">    This dictionary functions effectively as a superset of</span>
<span class="sd">    the relevant parameters.  The relevant parameters are given below:</span>
<span class="sd">    time : ndarray</span>
<span class="sd">        An array of scalars of time stamps in seconds.</span>
<span class="sd">    Theta : ndarray</span>
<span class="sd">        An array of scalars representing the polar angle component</span>
<span class="sd">        of the satelite in spherical coordinates.</span>
<span class="sd">    phi : ndarray</span>
<span class="sd">        An array of scalars representing the azimuth angle component</span>
<span class="sd">        of the satelite in spherical coordinates.</span>
<span class="sd">    r : ndarray</span>
<span class="sd">        An array of scalars representing the radial angle component</span>
<span class="sd">        of the satelite in spherical coordinates.</span>
<span class="sd">    B_base : ndarray</span>
<span class="sd">        An array of vectors of the magnetic field measurements.</span>
<span class="sd">        The vectors are assumed to be in the NEC coordinate system.</span>
<span class="sd">    B_core : ndarray, optional</span>
<span class="sd">        An array of vectors of the magnetic field component</span>
<span class="sd">        derived from a model of Earth&#39;s core.</span>
<span class="sd">    B_lithosphere : ndarray, optional</span>
<span class="sd">        An array of vectors of the magnetic field component</span>
<span class="sd">        derived from a model of the Earthø&#39;s lithosphere (crust).</span>
<span class="sd">    B_magnetosphere_primary : ndarray, optional</span>
<span class="sd">        An array of vectors of the magnetic field component</span>
<span class="sd">        derived from a model of the primary magnetosphere field.</span>
<span class="sd">    B_magnetosphere_secondary : ndarray, optional</span>
<span class="sd">        An array of vectors of the magnetic field component</span>
<span class="sd">        derived from a model of the induced field from the magnetosphere.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    The return is a tuple consiting of the following:</span>
<span class="sd">    time : ndarray</span>
<span class="sd">        An ndarray of  scalars describing the time each point</span>
<span class="sd">        in the calculations corrisond to.</span>
<span class="sd">        Note that it is off compared to the parameter time.</span>
<span class="sd">    position : ndarray</span>
<span class="sd">        An ndarray of spherical coordinates describing the postion</span>
<span class="sd">        of each point in the time series where the calculations</span>
<span class="sd">        are suppose to apply at. The coordinates are arranged as</span>
<span class="sd">        theta, phi, r.</span>
<span class="sd">        Note tht this is off compared to the parameter positions.</span>
<span class="sd">    irc : ndarray</span>
<span class="sd">        An ndarray of vectors of the radial currents (the radial components,</span>
<span class="sd">        of currents) found when solving one of Maxwells equations</span>
<span class="sd">        on the magnetic field.</span>
<span class="sd">        Note that this is given in the VSC (spacecraft velocity) frame.</span>
<span class="sd">    fac : ndarray</span>
<span class="sd">        An ndarray of vectors of the field alligned currents.</span>
<span class="sd">        Note that this is given in the VSC (spacecraft velocity) frame.</span>
<span class="sd">    V : ndarray</span>
<span class="sd">        An ndarray of vectors of the velocity in the NEC frame.</span>
<span class="sd">    V_VSC : ndarray</span>
<span class="sd">        An ndarray of vectors of the velocity in the VSC frame.</span>
<span class="sd">    pos_ltl : ndarray</span>
<span class="sd">        An ndarray of scalars of positions where local time is acounted for.</span>
<span class="sd">        Each position reference the same position as positions output.</span>
<span class="sd">        Note tht this is off compared to the parameter positions.</span>
<span class="sd">    inclination :</span>
<span class="sd">        An ndarray of scalars of the inclination of the aproximation </span>
<span class="sd">        of the magnetic field, where the calculations</span>
<span class="sd">        are supposed to be applied at.</span>
<span class="sd">        </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from pyfac.fac import *  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; time = np.arange(0,10,0.1)</span>
<span class="sd">    &gt;&gt;&gt; positions = sw.pack_3d(np.sin(0.01 * time)*90,(0.01 * time % np.pi)/sw.TO_RADIANS ,np.ones(len(time)))</span>
<span class="sd">    &gt;&gt;&gt; B_res = np.random.randn(len(time),3)* sw.as_3d(10 *positions[:,1])</span>
<span class="sd">    &gt;&gt;&gt; B_core = sw.as_3d(positions[:,2])*sw.pack_3d(np.sin(positions[:,0]),np.zeros(len(time)),2*np.cos(positions[:,0]))</span>
<span class="sd">    &gt;&gt;&gt; single_sat_fac_full({&#39;time&#39;:time,&#39;Theta&#39;:positions[:,0],&#39;phi&#39;:positions[:,1],&#39;r&#39;:positions[:,2],&#39;B_base&#39;:B_res+B_core,&#39;B_core&#39;:B_core})  # doctest: +ELLIPSIS</span>
<span class="sd">    (array([...]), array([[...]]), array([...]), array([...]), array([[...]]), array([[...]]), array([[...]]), array([...]))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">single_sat_fac</span><span class="p">(</span>
        <span class="n">input_data</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">],</span>
        <span class="n">sw</span><span class="o">.</span><span class="n">pack_3d</span><span class="p">(</span><span class="n">input_data</span><span class="p">[</span><span class="s1">&#39;Theta&#39;</span><span class="p">],</span> <span class="n">input_data</span><span class="p">[</span><span class="s1">&#39;phi&#39;</span><span class="p">],</span> <span class="n">input_data</span><span class="p">[</span><span class="s1">&#39;r&#39;</span><span class="p">]),</span>
        <span class="o">*</span><span class="n">split_models</span><span class="p">(</span><span class="n">input_data</span><span class="p">[</span><span class="s1">&#39;B_base&#39;</span><span class="p">],</span> <span class="o">*</span><span class="p">[</span><span class="n">input_data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span>
            <span class="s1">&#39;B_core&#39;</span><span class="p">,</span> <span class="s1">&#39;B_lithosphere&#39;</span><span class="p">,</span>
            <span class="s1">&#39;B_magnetosphere_primary&#39;</span><span class="p">,</span>
            <span class="s1">&#39;B_magnetosphere_secondary&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">input_data</span><span class="p">]))</span></div>


<div class="viewcode-block" id="fetch_data"><a class="viewcode-back" href="../../reference.html#swarmpyfac.fac.fetch_data">[docs]</a><span class="k">def</span> <span class="nf">fetch_data</span><span class="p">(</span><span class="n">force_download</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">temp_file</span><span class="o">=</span><span class="s1">&#39;tempdata.cdf&#39;</span><span class="p">,</span><span class="o">**</span><span class="n">options</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Fetch cdf form data from a file or by downloading it.</span>
<span class="sd">    </span>
<span class="sd">    This function is made to hide the complexity of getting</span>
<span class="sd">    data from a cdf file that you might need to download first.</span>
<span class="sd">    The idea is a dowloaded file will be saved as some temporary file</span>
<span class="sd">    temp_file and then opened.</span>
<span class="sd">    If the file have already been downloaded then it will be assumed</span>
<span class="sd">    that the file at temp_file is the one wanted, unless</span>
<span class="sd">    force_download is set to true to indicate that this cache</span>
<span class="sd">    should be flushed and overwritten by a new download.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    force_download : boolean, optional</span>
<span class="sd">        A flag on whether to force downloading of the data and</span>
<span class="sd">        thereby overwrite the temp_file if it already exists.</span>
<span class="sd">        If set to False the program will only download the data</span>
<span class="sd">        if it cannot find the temp_file.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    temp_file : string</span>
<span class="sd">        A string of the file path for where the downloaded file should be.</span>
<span class="sd">        If the file already exists then this may take priority</span>
<span class="sd">        depending on the force_download flag.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        A dictionary map of _name_pairings, where the values</span>
<span class="sd">        have been replaced with the data entry of</span>
<span class="sd">        the previous value.</span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from pyfac.fac import *  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; fetch_data()  # doctest: +ELLIPSIS, +SKIP</span>
<span class="sd">    {...}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name_pairings</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;name_pairings&#39;</span><span class="p">,</span><span class="n">_name_pairings</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">temp_file</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">temp_file</span><span class="p">)</span> <span class="ow">or</span> <span class="n">force_download</span><span class="p">:</span>
        <span class="n">sw</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">sw</span><span class="o">.</span><span class="n">request_data</span><span class="p">,</span><span class="n">options</span><span class="p">,</span><span class="n">target_file</span><span class="o">=</span><span class="n">temp_file</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sw</span><span class="o">.</span><span class="n">read_cdf</span><span class="p">(</span><span class="n">temp_file</span><span class="p">,</span> <span class="o">**</span><span class="n">name_pairings</span><span class="p">)</span></div>


<div class="viewcode-block" id="fac_from_file"><a class="viewcode-back" href="../../reference.html#swarmpyfac.fac.fac_from_file">[docs]</a><span class="k">def</span> <span class="nf">fac_from_file</span><span class="p">(</span><span class="o">**</span><span class="n">options</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Compute FAC for a single satelite from data in an outside source.</span>
<span class="sd">    </span>
<span class="sd">    This function is inteded as the topmost function of this module.</span>
<span class="sd">    It is therefore suggested to just strait up use this function,</span>
<span class="sd">    when one wants to use this as a module instead of as a script.</span>
<span class="sd">    </span>
<span class="sd">    The function will read a cdf-file or download it,</span>
<span class="sd">    if such a file is not already cached.</span>
<span class="sd">    It will then calculate FAC (field aligned currents),</span>
<span class="sd">    and other related measures, and return those results.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    **options</span>
<span class="sd">        options to be passed to other lower level function(s),</span>
<span class="sd">        mainly fetch_data.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    The return is a tuple consiting of the following:</span>
<span class="sd">    time : ndarray</span>
<span class="sd">        An ndarray of  scalars describing the time each point</span>
<span class="sd">        in the calculations corrisond to.</span>
<span class="sd">        Note that it is off compared to the parameter time.</span>
<span class="sd">    position : ndarray</span>
<span class="sd">        An ndarray of spherical coordinates describing the postion</span>
<span class="sd">        of each point in the time series where the calculations</span>
<span class="sd">        are suppose to apply at. The coordinates are arranged as</span>
<span class="sd">        theta, phi, r.</span>
<span class="sd">        Note tht this is off compared to the parameter positions.</span>
<span class="sd">    irc : ndarray</span>
<span class="sd">        An ndarray of vectors of the radial currents (the radial components,</span>
<span class="sd">        of currents) found when solving one of Maxwells equations</span>
<span class="sd">        on the magnetic field.</span>
<span class="sd">        Note that this is given in the VSC (spacecraft velocity) frame.</span>
<span class="sd">    fac : ndarray</span>
<span class="sd">        An ndarray of vectors of the field alligned currents.</span>
<span class="sd">        Note that this is given in the VSC (spacecraft velocity) frame.</span>
<span class="sd">    V : ndarray</span>
<span class="sd">        An ndarray of vectors of the velocity in the NEC frame.</span>
<span class="sd">    V_VSC : ndarray</span>
<span class="sd">        An ndarray of vectors of the velocity in the VSC frame.</span>
<span class="sd">    pos_ltl : ndarray</span>
<span class="sd">        An ndarray of scalars of positions where local time is acounted for.</span>
<span class="sd">        Each position reference the same position as positions output.</span>
<span class="sd">        Note tht this is off compared to the parameter positions.</span>
<span class="sd">    inclination :</span>
<span class="sd">        An ndarray of scalars of the inclination of the aproximation </span>
<span class="sd">        of the magnetic field, where the calculations</span>
<span class="sd">        are supposed to be applied at.</span>
<span class="sd">            </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from pyfac.fac import *  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; fac_from_file()  # doctest: +ELLIPSIS, +SKIP</span>
<span class="sd">    (array([...]), array([[...]]), array([...]), array([...]), array([[...]]), array([[...]]), array([[...]]), array([...]))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">input_data</span> <span class="o">=</span> <span class="n">sw</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">fetch_data</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="n">use_pop</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">input_data</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span> <span class="o">*=</span> <span class="mf">0.001</span>  <span class="c1"># conversion to seconds</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">single_sat_fac_full</span><span class="p">(</span><span class="n">input_data</span><span class="p">),</span>
            <span class="n">input_data</span><span class="p">)</span></div>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="c1"># Test docstrings</span>
    <span class="kn">import</span> <span class="nn">doctest</span>
    <span class="n">doctest</span><span class="o">.</span><span class="n">testmod</span><span class="p">()</span>

    <span class="n">results</span><span class="p">,</span> <span class="n">input_data</span> <span class="o">=</span> <span class="n">fac_from_file</span><span class="p">()</span>
    <span class="n">lat</span><span class="p">,</span> <span class="n">fac</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="mi">1</span><span class="p">][:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">results</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">reference</span> <span class="o">=</span> <span class="n">sw</span><span class="o">.</span><span class="n">read_cdf</span><span class="p">(</span>
        <span class="s1">&#39;otherData/SW_OPER_FACATMS_2F_20160101T000000_20160101T235959_0301.cdf&#39;</span><span class="p">,</span>
        <span class="n">lat</span><span class="o">=</span><span class="s1">&#39;Latitude&#39;</span><span class="p">,</span>
        <span class="n">fac</span><span class="o">=</span><span class="s1">&#39;FAC&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">reference</span><span class="p">[</span><span class="s1">&#39;lat&#39;</span><span class="p">],</span> <span class="n">reference</span><span class="p">[</span><span class="s1">&#39;FAC&#39;</span><span class="p">],</span> <span class="s1">&#39;b&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">lat</span><span class="p">,</span> <span class="n">fac</span><span class="p">,</span> <span class="s1">&#39;r:&#39;</span><span class="p">)</span>
    <span class="c1"># plt.show()</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">SwarmPyFAC 0.1.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2019, Ask Neve Gamby.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.4.
    </div>
  </body>
</html>